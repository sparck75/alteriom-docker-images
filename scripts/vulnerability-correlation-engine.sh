#!/bin/bash

# Vulnerability Correlation Engine for alteriom-docker-images
# Part of Phase 2B: Enhanced Correlation & Intelligence
# Provides cross-tool vulnerability correlation, severity normalization, and duplicate detection

set -euo pipefail

# Configuration
SCAN_RESULTS_DIR="${SCAN_RESULTS_DIR:-comprehensive-security-results}"
CORRELATION_OUTPUT_DIR="${SCAN_RESULTS_DIR}/correlation"
CORRELATION_REPORT="${CORRELATION_OUTPUT_DIR}/vulnerability-correlation-report.json"
NORMALIZED_REPORT="${CORRELATION_OUTPUT_DIR}/normalized-vulnerabilities.json"
DEDUPLICATED_REPORT="${CORRELATION_OUTPUT_DIR}/deduplicated-vulnerabilities.json"
RISK_ASSESSMENT_REPORT="${CORRELATION_OUTPUT_DIR}/contextual-risk-assessment.json"

# Color definitions for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
NC='\033[0m' # No Color

# Check if terminal supports colors (disable in CI/non-interactive environments)
if [[ ! -t 1 ]] || [[ "${NO_COLOR:-}" ]] || [[ "${CI:-}" ]]; then
    RED='' GREEN='' YELLOW='' BLUE='' PURPLE='' CYAN='' WHITE='' NC=''
fi

# Print status messages
print_status() {
    local status=$1
    local message=$2
    case $status in
        "SUCCESS") echo -e "${GREEN}✅ $message${NC}" ;;
        "WARNING") echo -e "${YELLOW}⚠️  $message${NC}" ;;
        "ERROR") echo -e "${RED}❌ $message${NC}" ;;
        "INFO") echo -e "${BLUE}ℹ️  $message${NC}" ;;
        "CORRELATE") echo -e "${PURPLE}🔗 $message${NC}" ;;
        "ANALYZE") echo -e "${CYAN}📊 $message${NC}" ;;
    esac
}

# Enhanced error handling
error_handler() {
    local line_no=$1
    local error_code=$2
    print_status "ERROR" "Vulnerability correlation failed at line $line_no (exit code: $error_code)"
    echo "🔍 Check the logs above for specific error details" >&2
    echo "📊 Partial correlation results may be available in: $CORRELATION_OUTPUT_DIR" >&2
    exit $error_code
}

# Set up error trap
trap 'error_handler ${LINENO} $?' ERR

# Initialize correlation environment
initialize_correlation_environment() {
    print_status "INFO" "Initializing vulnerability correlation environment..."
    
    # Create output directory structure
    mkdir -p "$CORRELATION_OUTPUT_DIR"/{raw,processed,reports,metrics}
    
    # Set appropriate permissions
    find "$CORRELATION_OUTPUT_DIR" -type d -exec chmod 750 {} + 2>/dev/null || true
    find "$CORRELATION_OUTPUT_DIR" -type f -exec chmod 640 {} + 2>/dev/null || true
    
    print_status "SUCCESS" "Correlation environment initialized"
}

# Extract vulnerabilities from different tools
extract_vulnerabilities() {
    print_status "CORRELATE" "Extracting vulnerabilities from security scan results..."
    
    local trivy_vulnerabilities=0
    local safety_vulnerabilities=0
    local grype_vulnerabilities=0
    local hadolint_issues=0
    
    # Extract Trivy vulnerabilities
    if [[ -f "$SCAN_RESULTS_DIR/trivy-results.json" ]]; then
        print_status "INFO" "Processing Trivy results..."
        jq -r '.Results[]?.Vulnerabilities[]? | {
            id: .VulnerabilityID,
            severity: .Severity,
            title: .Title,
            description: .Description,
            tool: "trivy",
            package: .PkgName,
            version: .InstalledVersion,
            fixed_version: .FixedVersion,
            score: .CVSS.nvd.V3Score,
            published_date: .PublishedDate
        }' "$SCAN_RESULTS_DIR/trivy-results.json" > "$CORRELATION_OUTPUT_DIR/raw/trivy-vulnerabilities.json" 2>/dev/null || true
        trivy_vulnerabilities=$(jq -s 'length' "$CORRELATION_OUTPUT_DIR/raw/trivy-vulnerabilities.json" 2>/dev/null || echo 0)
    fi
    
    # Extract Safety vulnerabilities (Python packages)
    if [[ -f "$SCAN_RESULTS_DIR/safety-results.json" ]]; then
        print_status "INFO" "Processing Safety results..."
        # Safety output format may vary, handle gracefully
        if jq empty "$SCAN_RESULTS_DIR/safety-results.json" 2>/dev/null; then
            jq -r '.[] | {
                id: .vulnerability_id,
                severity: "HIGH",
                title: .vulnerability,
                description: .vulnerability,
                tool: "safety",
                package: .package,
                version: .installed_version,
                fixed_version: null,
                score: null,
                published_date: null
            }' "$SCAN_RESULTS_DIR/safety-results.json" > "$CORRELATION_OUTPUT_DIR/raw/safety-vulnerabilities.json" 2>/dev/null || true
            safety_vulnerabilities=$(jq -s 'length' "$CORRELATION_OUTPUT_DIR/raw/safety-vulnerabilities.json" 2>/dev/null || echo 0)
        fi
    fi
    
    # Extract Hadolint issues (Dockerfile linting)
    if [[ -f "$SCAN_RESULTS_DIR/hadolint-results.json" ]]; then
        print_status "INFO" "Processing Hadolint results..."
        if jq empty "$SCAN_RESULTS_DIR/hadolint-results.json" 2>/dev/null; then
            jq -r '.[] | {
                id: (.code // "HADOLINT-" + (.line | tostring)),
                severity: (if .level == "error" then "HIGH" elif .level == "warning" then "MEDIUM" else "LOW" end),
                title: .message,
                description: .message,
                tool: "hadolint",
                package: "dockerfile",
                version: null,
                fixed_version: null,
                score: null,
                published_date: null
            }' "$SCAN_RESULTS_DIR/hadolint-results.json" > "$CORRELATION_OUTPUT_DIR/raw/hadolint-vulnerabilities.json" 2>/dev/null || true
            hadolint_issues=$(jq -s 'length' "$CORRELATION_OUTPUT_DIR/raw/hadolint-vulnerabilities.json" 2>/dev/null || echo 0)
        fi
    fi
    
    print_status "ANALYZE" "Vulnerability extraction summary:"
    echo "  - Trivy vulnerabilities: $trivy_vulnerabilities"
    echo "  - Safety vulnerabilities: $safety_vulnerabilities"
    echo "  - Hadolint issues: $hadolint_issues"
    echo "  - Total extracted: $((trivy_vulnerabilities + safety_vulnerabilities + hadolint_issues))"
    
    print_status "SUCCESS" "Vulnerability extraction completed"
}

# Normalize severity levels across tools
normalize_severity() {
    print_status "CORRELATE" "Normalizing severity levels across tools..."
    
    # Combine all vulnerabilities and normalize severity
    local combined_vulns="$CORRELATION_OUTPUT_DIR/processed/combined-vulnerabilities.json"
    
    # Combine all extracted vulnerabilities
    {
        [[ -f "$CORRELATION_OUTPUT_DIR/raw/trivy-vulnerabilities.json" ]] && cat "$CORRELATION_OUTPUT_DIR/raw/trivy-vulnerabilities.json"
        [[ -f "$CORRELATION_OUTPUT_DIR/raw/safety-vulnerabilities.json" ]] && cat "$CORRELATION_OUTPUT_DIR/raw/safety-vulnerabilities.json"
        [[ -f "$CORRELATION_OUTPUT_DIR/raw/hadolint-vulnerabilities.json" ]] && cat "$CORRELATION_OUTPUT_DIR/raw/hadolint-vulnerabilities.json"
    } | jq -s '.' > "$combined_vulns" 2>/dev/null || echo '[]' > "$combined_vulns"
    
    # Normalize severity levels and calculate normalized scores
    jq '[.[] | . + {
        normalized_severity: (
            if (.severity == "CRITICAL" or .severity == "HIGH") then "HIGH"
            elif (.severity == "MEDIUM" or .severity == "warning") then "MEDIUM"
            elif (.severity == "LOW" or .severity == "info") then "LOW"
            else "UNKNOWN"
            end
        ),
        normalized_score: (
            if (.score and (.score | type) == "number") then .score
            elif (.severity == "CRITICAL") then 9.0
            elif (.severity == "HIGH") then 7.0
            elif (.severity == "MEDIUM") then 5.0
            elif (.severity == "LOW") then 3.0
            else 1.0
            end
        ),
        correlation_id: (.tool + "-" + (.id // "unknown") + "-" + (.package // "unknown"))
    }]' "$combined_vulns" > "$NORMALIZED_REPORT"
    
    local normalized_count=$(jq 'length' "$NORMALIZED_REPORT" 2>/dev/null || echo 0)
    print_status "SUCCESS" "Severity normalization completed ($normalized_count vulnerabilities processed)"
}

# Detect and remove duplicate vulnerabilities
detect_duplicates() {
    print_status "CORRELATE" "Detecting and filtering duplicate vulnerabilities..."
    
    # Group vulnerabilities by CVE ID, package name, and description to find duplicates
    jq 'group_by(.id, .package) | 
        map({
            group_key: (.[0].id + "-" + (.[0].package // "unknown")),
            vulnerabilities: .,
            is_duplicate_group: (length > 1),
            primary_vulnerability: .[0],
            duplicate_sources: [.[].tool] | unique,
            highest_severity: ([.[].normalized_score] | max)
        })' "$NORMALIZED_REPORT" > "$CORRELATION_OUTPUT_DIR/processed/grouped-vulnerabilities.json"
    
    # Create deduplicated report with enhanced information
    jq '[
        .[] | 
        .primary_vulnerability + {
            duplicate_sources: .duplicate_sources,
            is_deduplicated: .is_duplicate_group,
            confidence_score: (
                if .is_duplicate_group then 
                    (.duplicate_sources | length) * 0.2 + 0.8
                else 
                    0.8
                end
            ),
            normalized_score: .highest_severity
        }
    ]' "$CORRELATION_OUTPUT_DIR/processed/grouped-vulnerabilities.json" > "$DEDUPLICATED_REPORT"
    
    local total_count=$(jq 'length' "$NORMALIZED_REPORT" 2>/dev/null || echo 0)
    local deduplicated_count=$(jq 'length' "$DEDUPLICATED_REPORT" 2>/dev/null || echo 0)
    local duplicates_removed=$((total_count - deduplicated_count))
    
    print_status "ANALYZE" "Duplicate detection results:"
    echo "  - Total vulnerabilities: $total_count"
    echo "  - After deduplication: $deduplicated_count"
    echo "  - Duplicates removed: $duplicates_removed"
    
    print_status "SUCCESS" "Duplicate detection completed"
}

# Perform contextual risk assessment
contextual_risk_assessment() {
    print_status "CORRELATE" "Performing contextual risk assessment..."
    
    # Add business context and risk factors
    jq '[
        .[] | . + {
            business_impact: (
                if (.normalized_severity == "HIGH" and ((.package // "") | contains("python") or contains("pip") or contains("npm") or contains("docker"))) then "HIGH"
                elif (.normalized_severity == "MEDIUM" and ((.package // "") | contains("system") or contains("core") or contains("base"))) then "MEDIUM"
                elif (.normalized_severity == "HIGH") then "MEDIUM"
                elif (.normalized_severity == "MEDIUM") then "LOW"
                else "MINIMAL"
                end
            ),
            exploitability: (
                if (.normalized_score >= 7.0) then "HIGH"
                elif (.normalized_score >= 5.0) then "MEDIUM"
                elif (.normalized_score >= 3.0) then "LOW"
                else "MINIMAL"
                end
            ),
            remediation_complexity: (
                if (.fixed_version) then "LOW"
                elif (.tool == "hadolint") then "MEDIUM"
                elif (.package) then "MEDIUM"
                else "HIGH"
                end
            ),
            priority_score: (
                (.normalized_score // 1.0) * 
                (if .business_impact == "HIGH" then 1.5 elif .business_impact == "MEDIUM" then 1.2 else 1.0 end) *
                (if .exploitability == "HIGH" then 1.3 elif .exploitability == "MEDIUM" then 1.1 else 1.0 end) *
                (.confidence_score // 1.0)
            )
        }
    ] | sort_by(-.priority_score)' "$DEDUPLICATED_REPORT" > "$RISK_ASSESSMENT_REPORT"
    
    # Generate risk summary metrics
    jq '{
        total_vulnerabilities: length,
        risk_distribution: {
            high_risk: [.[] | select(.business_impact == "HIGH")] | length,
            medium_risk: [.[] | select(.business_impact == "MEDIUM")] | length,
            low_risk: [.[] | select(.business_impact == "LOW")] | length,
            minimal_risk: [.[] | select(.business_impact == "MINIMAL")] | length
        },
        exploitability_distribution: {
            high_exploitability: [.[] | select(.exploitability == "HIGH")] | length,
            medium_exploitability: [.[] | select(.exploitability == "MEDIUM")] | length,
            low_exploitability: [.[] | select(.exploitability == "LOW")] | length
        },
        remediation_complexity: {
            easy_fixes: [.[] | select(.remediation_complexity == "LOW")] | length,
            moderate_fixes: [.[] | select(.remediation_complexity == "MEDIUM")] | length,
            complex_fixes: [.[] | select(.remediation_complexity == "HIGH")] | length
        },
        top_priority_vulnerabilities: [.[] | select(.priority_score >= 7.0)] | length,
        average_priority_score: (if length > 0 then ([.[].priority_score] | add / length) else 0 end),
        timestamp: "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'"
    }' "$RISK_ASSESSMENT_REPORT" > "$CORRELATION_OUTPUT_DIR/reports/risk-summary.json"
    
    local total_vulns=$(jq '.total_vulnerabilities' "$CORRELATION_OUTPUT_DIR/reports/risk-summary.json" 2>/dev/null || echo 0)
    local high_risk=$(jq '.risk_distribution.high_risk' "$CORRELATION_OUTPUT_DIR/reports/risk-summary.json" 2>/dev/null || echo 0)
    
    print_status "ANALYZE" "Risk assessment results:"
    echo "  - Total assessed vulnerabilities: $total_vulns"
    echo "  - High business impact: $high_risk"
    echo "  - Average priority score: $(jq -r '.average_priority_score' "$CORRELATION_OUTPUT_DIR/reports/risk-summary.json" 2>/dev/null || echo "N/A")"
    
    print_status "SUCCESS" "Contextual risk assessment completed"
}

# Generate comprehensive correlation report
generate_correlation_report() {
    print_status "CORRELATE" "Generating comprehensive correlation report..."
    
    # Create comprehensive JSON report
    jq -n --slurpfile vulnerabilities "$RISK_ASSESSMENT_REPORT" \
         --slurpfile summary "$CORRELATION_OUTPUT_DIR/reports/risk-summary.json" '{
        correlation_metadata: {
            timestamp: "'"$(date -u +%Y-%m-%dT%H:%M:%SZ)"'",
            phase: "2B",
            correlation_engine_version: "1.0.0",
            scan_results_directory: "'"$SCAN_RESULTS_DIR"'"
        },
        vulnerability_summary: $summary[0],
        correlated_vulnerabilities: $vulnerabilities[0],
        correlation_metrics: {
            tools_processed: ($vulnerabilities[0] | [.[].tool] | unique | length),
            correlation_accuracy: (if ($vulnerabilities[0] | length) > 0 then ($vulnerabilities[0] | [.[].confidence_score] | add / length) else 0 end),
            deduplication_efficiency: (
                ($vulnerabilities[0] | length) as $final_count |
                (($vulnerabilities[0] | [.[].is_deduplicated] | map(select(. == true)) | length) + $final_count) as $original_count |
                if $original_count > 0 then (($original_count - $final_count) / $original_count * 100) else 0 end
            )
        }
    }' > "$CORRELATION_REPORT"
    
    # Generate human-readable summary report
    cat > "$CORRELATION_OUTPUT_DIR/reports/correlation-summary.txt" << EOF
# Vulnerability Correlation Report - Phase 2B
Generated: $(date -u)

## Executive Summary
$(jq -r '.vulnerability_summary | "Total Vulnerabilities: \(.total_vulnerabilities)
High Risk Issues: \(.risk_distribution.high_risk)
Medium Risk Issues: \(.risk_distribution.medium_risk)
Easy Fixes Available: \(.remediation_complexity.easy_fixes)"' "$CORRELATION_REPORT")

## Correlation Metrics
$(jq -r '.correlation_metrics | "Tools Processed: \(.tools_processed)
Correlation Accuracy: \(.correlation_accuracy * 100 | floor)%
Deduplication Efficiency: \(.deduplication_efficiency | floor)%"' "$CORRELATION_REPORT")

## Risk Distribution
$(jq -r '.vulnerability_summary.risk_distribution | to_entries[] | "- \(.key | gsub("_"; " ") | ascii_upcase): \(.value)"' "$CORRELATION_REPORT")

## Top Priority Recommendations
$(jq -r '.correlated_vulnerabilities[0:5][] | "- \(.title) (Priority: \(.priority_score | . * 10 | floor / 10))"' "$CORRELATION_REPORT" 2>/dev/null || echo "No high priority vulnerabilities identified")

---
Report generated by Vulnerability Correlation Engine v1.0.0
EOF
    
    print_status "SUCCESS" "Comprehensive correlation report generated"
}

# Main execution function
main() {
    echo "🔗 Vulnerability Correlation Engine - Phase 2B"
    echo "=============================================="
    echo ""
    
    local start_time=$(date +%s)
    
    # Execute correlation phases
    initialize_correlation_environment
    extract_vulnerabilities
    normalize_severity
    detect_duplicates
    contextual_risk_assessment
    generate_correlation_report
    
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    
    echo ""
    print_status "SUCCESS" "Vulnerability correlation completed in ${duration}s"
    echo ""
    print_status "INFO" "Correlation reports available in: $CORRELATION_OUTPUT_DIR"
    echo "  📊 Comprehensive report: $CORRELATION_REPORT"
    echo "  📝 Summary report: $CORRELATION_OUTPUT_DIR/reports/correlation-summary.txt"
    echo "  🔍 Risk assessment: $RISK_ASSESSMENT_REPORT"
    echo ""
    
    # Display quick summary
    if [[ -f "$CORRELATION_REPORT" ]]; then
        local total_vulns=$(jq -r '.vulnerability_summary.total_vulnerabilities' "$CORRELATION_REPORT" 2>/dev/null || echo "0")
        local high_risk=$(jq -r '.vulnerability_summary.risk_distribution.high_risk' "$CORRELATION_REPORT" 2>/dev/null || echo "0")
        
        print_status "ANALYZE" "Quick Summary: $total_vulns vulnerabilities analyzed, $high_risk high-risk issues identified"
        
        if [[ "$high_risk" -gt 0 ]]; then
            print_status "WARNING" "High-risk vulnerabilities detected - review correlation report for details"
            return 1
        else
            print_status "SUCCESS" "No high-risk vulnerabilities detected through correlation analysis"
        fi
    fi
}

# Execute main function
main "$@"